# ES6: Hey look, JS is good now!. ES6 gettin good. JavaScript gets serious: ES6 and beyond.

>> If you weren't paying close attention you may have missed JavaScript morphing into a really good language. Shedding warts from its "Lisp in C's Clothing" past, the latest updates bring a stack of functional features that make coding in Plain ol' JavaScript plain good fun. Earle will cover what's here, what's just around the corner, and argue that it may be time to put your transpiler out to pasture.

## Intro
[js < java, js < lisp]
Basically there are two types of groups of JavaScript dis-likers: those who think JavaScript is a poor man's Java, and those who think that JavaScript is a poor man's lisp. Or to put it another way:

[silly vs reasonable] Some people make fun of javascript for *silly reasons*, and some make fun of javascript for *reasonable* reasons.

The core of the problem is the superficial rough spots (the silly reasons to hate js - dislike it sure, but hate?) are plainly visible: crazy "arguments" and other 'historicl hair' more commanly known as the "wats", while its flexible functional aspects are clunky to use (function/return, no tail call optimization) - leading to reasonable reasons to scoff at js.

[es6 fixes em] The next version of Javascript (Here I'm including things in teh harmony ECMAScript 6 specifctation, or ES6 - as well as a couple of things from ES5 that are beconing more mainstream) is a BIG version bump: far more interesting than any of the previous (except maybe with the introduction of map/reduce and friends, which i think had done a lot to encourage the use the functional javascript).

ES6 addresses many of the reasonable reasons quite well, adn even some of the silly reasons. Though the maximumly minimal class spec is not going to convince many java people to embrace it, just as "typed objects" aren't going to get haskell people drooling

The TC39 committee (the guys and gals resposible for choosing what goes in, and what is not it) have removed a stack of the warts and have sugar-sculpted up a lot of the rough edges - they've adding expresivness, consisesness and now a nice programming language.

In the next 30 minutes I'm going to do the following things:
 * This intro (2 mins)
 * Rant about transpilers (3 mins)
 * Seque seemlessly into functional rendering (5 mins)
 * Live code it in ES6 (15 mins)
 * Re-state my rant about transiplers (3 mins), and probably make fun of java again.

with 2 mins for technical difficulties.

 [slide of everythign] So, obvioulsy I'm not going to go into detail about every aspect of recent addtionls & es6 - I don't know every aspect, for one thing, and there's a lot in there: Promises, generators, object and array destructuring, text interpolation, proxies, modules, classes... A bunch of stuff that you probably already know. But I just want to how you a "real" peice of code can benefit from the update, as most of the stuff on ES6 is shown in isolation.

## The rise of the transpiler

[the rise of the transpiler]
 ES6 was strongly influecnece bythe rise of transpiling: compiling to similar level of abstraction. Which is differs from regular comiling which goes to lower levels of abstraction. If it's the same level abstraction then it sounds like uneccesary overhead - more complex build system and workflow that can and will fail, and outpu code that looks like it was generated by Microsoft Word - so why bother? Over the years I've worked with a lot of languages: from ASP classic, to .NET and Java, Scala, Clojure, even some small projects in Haskell - and ALL have had good and bad points. But the dislike from anti-javascript people _almost_ rivals the anti PHP people. The primary reason for this is, I think, it's ubiquity.

[aint no party]

For the longest time, JavaScript was your only option for targeting teh web - and nerds HATE to be told that they HAVE to do something. But then, came the transpiler: the primary weapon for teh Javascript opponent.

[trans for good] The first transpilers emerged to address some of the *reasonable* reasons to not use plain old javascript. Coffeescript was extremely successful in highlighting that javascript could easily be made more expressive and consise. Sure, it was annoying to have to compile code to be run in the browser - and it had some weird whitespace issues that would drive you mad, but it bordered on being worth it - the clunkyness of JS had been erased: it was a revelation. So much so that a host of features from it are now in teh  ECMAScript 6 specification that have just now started trickling into the browsers.

[trans for bad] I don't want to say "evil"... *cough* Dart *cough* - But the success of CoffeeScript opened the floodgates... transpilers ddin't have to just fix warts in JavaSCript: they could do whatever they wanted. This lead to some cool languagee ports like clojurescript as well as some really interesting new language that use JavaScript as base, rather than scrapping it all together: Roy.js, and even Typescript.

The irony is that the olny rason transpilers are so powerful and easy to write is that JavaScript is a good language: in the 10 days brenden iche had to create the langauge he made some important and fantastic decisions. Trying to write PureSCript in Java would not be fun.

[why not tp]
I'm not going to drop any bombshells here - I'm not against traspiling in general, but want everyone to at least admit there's a real and tangable cost.

There is a cost to transpiling, no matter how much you love your new environment. It's very likely that you and your team consider that cost worthwhile - but it's still a negative, a cost taht you have to consider.

The workflow for JS goes: JS => browser. The transpiled process goes Host => JS => Browser. That is what compelexity means: the develpment workflow is 33% greater, the debug process gets a level deeper (even with source maps).

	- fruity loops file => rendered wav
	- transpiled project => exported javascript

[so never transpile?] Derr, no. The idea of web standards and the open web. Just fix js

### es6 themes

[slide: goals]

- Harmony goals & themes: http://wiki.ecmascript.org/doku.php?id=harmony:harmony

Obviously my thinking is in line wht the comimitte members of of TC39... Be a better language for writing: "code generators targeting the new edition." - so, My rant is not of concern te TC39. Damn guys - we have a crazy monolpoly and can flex our ubiquitis streangth and they go be nice.... Best way to evolve the lang is not to add every feature under the sun, but add a few powerful features that let you evolve the langauge itsefl

Modules, proxies, typed objects - all let the user grow the langauge. It's not quite macros, but ...

"grow to shrink" (be, from Harmony of my dreams) -  shrink — or not grow, or grow less — the opt-in Harmony language by excluding misfeatures of “classic JS”

"JS is in fact more usable and smaller in its critical dimensions."

rquirement: how much are we going to get? "Keep the language pleasant for casual developers." means we won't be haskell any time soon.

- Language Reform, the “better carrots” needed to lead users away from bad forms

Remove (via opt-in versioning or pragmas) confusing or troublesome constructs.

- Why it's important - more than syntactic sugar. more consise and expressive

Provide syntactic conveniences for: good abstraction patterns; high integrity patterns; defined by desugaring into kernel semantics.

 Be a better language for writing complex applications;



## functional rendering

- intro: will do functors and monads made from lamdas. just kidding...

not gunna talk about tech from 1969... [atari] 1978.

The atari 2600 machine only had 128 bytes of RAM and cartridges could only store 4k of data - so the rendering couldn't possibly be done via a screen buffer - it worked was via a technique called "Racing the Beam". clock cycles === screen space.

- opengl

Once memory got cheaper and CPUs faster, imperitve methods of drawing became the norm: screens images were buffered up and displayed at once, you could ... then we got graphics card with gpus that are good at crunching numbers really fast... so fast that to get the cool effects you can write programs that run for every pixel, every frame. These are called fragment shaders.

[glsl.heroku.com]

Quite funcitonal in nature (though uses a lot of mutable state): take a pixel, apply a funciton to it, get a new pixel back. To get something on screen, you need to return back to the atari 2600 mindset - not thinking about the whole screen, but about functions.

[live code a bit of shader]

###  live coding
- coding a shader

-- in attempt to combine shaders, the atari 2600, and ES6 together I'm going to code up a... for the lowrez jam: 32 x 32 pixels, must be aligned to the grid (no "half pixels").

start with an es5 project that fills in the 32x32 pixel grid, using putpixel

First we'll move our base project to use modules.
- can be specified with module <name> { blah }


- Summary: much nicer, hey?

### and also..

So this focuesd on a bunch of the sugar

    "rest": Provide a better arguments so we can deprecate, obsolete, and some years hence burn with fire / salt the earth anything to do with arguments, foo.arguments, etc.

Proxies - emulating host objects, quasi-literals. for meta programming

Classes absolutely minimal class declaration syntax that all interested parties may be able to easily agree upon.  Attempting to extend this proposal is likely to result in dead-lock that would result in the inclusion of no class definition support in “ES6”.

- future: ES7: http://wiki.ecmascript.org/doku.php?id=strawman:strawman
http://esdiscuss.org
https://github.com/tc39/ecma262 // es7

typeof null == null;;;  "This proposal has been rejected. It was implemented in V8 but it turned out that it broke a lot of existing sites. In the spirit of One JavaScript this is not feasible."

http://wiki.ecmascript.org/doku.php?id=harmony:proposals

## timelines

   - remember ie5.5?
   Timelines for completion: Who's responsible. what's the deadline?

## summary
js is good now.
